<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=IBM Plex Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.patrickwu.uk","root":"/","scheme":"Muse","version":"7.7.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Authors: Chris Lattner, Joe Groff  IntroductionModern Cocoa development involves a lot of asynchronous programming using closures and completion handlers, but these APIs are hard to use.  This gets p">
<meta property="og:type" content="article">
<meta property="og:title" content="Async&#x2F;Await for Swift">
<meta property="og:url" content="http://blog.patrickwu.uk/22/03/2020/Async-Await-for-Swift/">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="Authors: Chris Lattner, Joe Groff  IntroductionModern Cocoa development involves a lot of asynchronous programming using closures and completion handlers, but these APIs are hard to use.  This gets p">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-22T04:44:48.000Z">
<meta property="article:modified_time" content="2020-03-22T04:50:35.298Z">
<meta property="article:author" content="patrick wu">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.patrickwu.uk/22/03/2020/Async-Await-for-Swift/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Async/Await for Swift | blog</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-161160600-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">illustrative abstractions</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>home</a>

  </li>
        <li class="menu-item menu-item-archive">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>archive</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>tags</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hZ2V0cm9u"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.patrickwu.uk/22/03/2020/Async-Await-for-Swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="patrick wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Async/Await for Swift
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">posted on</span>
              

              <time title="created: 22-03-2020 04:44:48 / modified: 04:50:35" itemprop="dateCreated datePublished" datetime="2020-03-22T04:44:48+00:00">22-03-2020</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>Authors: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhdHRuZXI=" title="https://github.com/lattner">Chris Lattner<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pja2FydGVy" title="https://github.com/jckarter">Joe Groff<i class="fa fa-external-link"></i></span></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Modern Cocoa development involves a lot of asynchronous programming using closures and completion handlers, but these APIs are hard to use.  This gets particularly problematic when many asynchronous operations are used, error handling is required, or control flow between asynchronous calls gets complicated.  This proposal describes a language extension to make this a lot more natural and less error prone.</p>
<p>This paper introduces a first class <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29yb3V0aW5l" title="https://en.wikipedia.org/wiki/Coroutine">Coroutine model<i class="fa fa-external-link"></i></span> to Swift. Functions can opt into to being <em>async</em>, allowing the programmer to compose complex logic involving asynchronous operations, leaving the compiler in charge of producing the necessary closures and state machines to implement that logic.</p>
<p>It is important to understand that this is proposing compiler support that is completely concurrency runtime-agnostic.  This proposal does not include a new runtime model (like “actors”) - it works just as well with GCD as with pthreads or another API. Furthermore, unlike designs in other languages, it is independent of specific coordination mechanisms, such as futures or channels, allowing these to be built as library feature. The only runtime support required is compiler support logic for transforming and manipulating the implicitly generated closures.</p>
<p>This draws some inspiration from an earlier proposal written by <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29sZWdhbnph" title="https://github.com/oleganza">Oleg Andreev<i class="fa fa-external-link"></i></span>, available <span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vb2xlZ2FuemEvNzM0MmVkODI5YmRkZDg2Zjc0MGE=" title="https://gist.github.com/oleganza/7342ed829bddd86f740a">here<i class="fa fa-external-link"></i></span>.  It has been significantly rewritten by <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhdHRuZXI=" title="https://github.com/lattner">Chris Lattner<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pja2FydGVy" title="https://github.com/jckarter">Joe Groff<i class="fa fa-external-link"></i></span>.</p>
<h2 id="Motivation-Completion-handlers-are-suboptimal"><a href="#Motivation-Completion-handlers-are-suboptimal" class="headerlink" title="Motivation: Completion handlers are suboptimal"></a>Motivation: Completion handlers are suboptimal</h2><p>To provide motivation for why it is important to do something here, lets look at some of the problems that Cocoa (and server/cloud) programmers frequently face.</p>
<h4 id="Problem-1-Pyramid-of-doom"><a href="#Problem-1-Pyramid-of-doom" class="headerlink" title="Problem 1: Pyramid of doom"></a>Problem 1: Pyramid of doom</h4><p>Sequence of simple operations is unnaturally composed in the nested blocks.  Here is a<br>made up example showing this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">(completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource <span class="keyword">in</span></span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource <span class="keyword">in</span></span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp <span class="keyword">in</span></span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData1 &#123; image <span class="keyword">in</span></span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This “pyramid of doom” makes it difficult to keep track of code that is running, and the stack of closures leads to many second order effects.</p>
<h4 id="Problem-2-Error-handling"><a href="#Problem-2-Error-handling" class="headerlink" title="Problem 2: Error handling"></a>Problem 2: Error handling</h4><p>Handling errors becomes difficult and very verbose. Swift 2 introduced an error handling model for synchronous code, but callback-based interfaces do not derive any benefit from it:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> imageTmp = imageTmp <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> imageResult = imageResult <span class="keyword">else</span> &#123;</span><br><span class="line">                        completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; image, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123;</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Problem-3-Conditional-execution-is-hard-and-error-prone"><a href="#Problem-3-Conditional-execution-is-hard-and-error-prone" class="headerlink" title="Problem 3: Conditional execution is hard and error-prone"></a>Problem 3: Conditional execution is hard and error-prone</h4><p>Conditionally executing an asynchronous function is a huge pain.  Perhaps the best approach is to write half of the code in a helper “continuation” closure that is conditionally executed, like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData3</span><span class="params">(recipient: Person, completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> continuation: (contents: image) -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">      <span class="comment">// ... continue and call completionBlock eventually</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        continuation(recipient.profilePicture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeImage &#123; image <span class="keyword">in</span></span><br><span class="line">            continuation(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Problem-4-Many-mistakes-are-easy-to-make"><a href="#Problem-4-Many-mistakes-are-easy-to-make" class="headerlink" title="Problem 4: Many mistakes are easy to make"></a>Problem 4: Many mistakes are easy to make</h4><p>It’s easy to bail out by simply returning without calling the appropriate block. When forgotten, the issue is very hard to debug:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData4</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you do not forget to call the block, you can still forget to return after that.<br>Thankfully <code>guard</code> syntax protects against that to some degree, but it’s not always relevant.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData5</span><span class="params">(recipient:Person, completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image = recipient.profilePicture &#123;</span><br><span class="line">            completionBlock(image) <span class="comment">// &lt;- forgot to return after calling the block</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Problem-5-Because-completion-handlers-are-awkward-too-many-APIs-are-defined-synchronously"><a href="#Problem-5-Because-completion-handlers-are-awkward-too-many-APIs-are-defined-synchronously" class="headerlink" title="Problem 5: Because completion handlers are awkward, too many APIs are defined synchronously"></a>Problem 5: Because completion handlers are awkward, too many APIs are defined synchronously</h4><p>This is hard to quantify, but the authors believe that the awkwardness of defining and using asynchronous APIs (using completion handlers) has led to many APIs being defined with apparently synchronous behavior, even when they can block.  This can lead to problematic performance and responsiveness problems in UI applications - e.g. spinning cursor.  It can also lead to the definition of APIs that cannot be used when asynchrony is critical to achieve scale, e.g. on the server.</p>
<h4 id="Problem-6-Other-“resumable”-computations-are-awkward-to-define"><a href="#Problem-6-Other-“resumable”-computations-are-awkward-to-define" class="headerlink" title="Problem 6: Other “resumable” computations are awkward to define"></a>Problem 6: Other “resumable” computations are awkward to define</h4><p>The problems described above are on specific case of a general class of problems involving “resumable” computations.   For example, if you want to write code that produces a list of squares of numbers, you might write something like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, if you want to write this as a Swift sequence, you have to define this as something that incrementally produces values.  There are multiple ways to do this (e.g. using <code>AnyIterator</code>, or the <code>sequence(state:,next:)</code> functions), but none of them approach the clarity and obviousness of the imperative form.</p>
<p>In contrast, languages that have generators allow you to write something more close to this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> seq = sequence &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">            yield(i*i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnySequence</span>(seq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is the responsibility of the compiler to transform the function into a form that incrementally produces values, by producing a state machine.</p>
<h2 id="Proposed-Solution-Coroutines"><a href="#Proposed-Solution-Coroutines" class="headerlink" title="Proposed Solution: Coroutines"></a>Proposed Solution: Coroutines</h2><p>These problem have been faced in many systems and many languages, and the abstraction of <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29yb3V0aW5l" title="https://en.wikipedia.org/wiki/Coroutine">coroutines<i class="fa fa-external-link"></i></span> is a standard way to address them.  Without delving too much into theory, coroutines are an extension of basic functions that allow a function to return a value <em>or be suspended</em>.  They can be used to implement generators, asynchronous models, and other capabilities - there is a large body of work on the theory, implementation, and optimization of them.</p>
<p>This proposal adds general coroutine support to Swift, biasing the nomenclature and terminology towards the most common use-case: defining and using asynchronous APIs, eliminating many of the problems working with completion handlers.  The choice of terminology (<code>async</code> vs <code>yields</code>) is a bikeshed topic which needs to be addressed, but isn’t pertinent to the core semantics of the model.  See <a href="#alternate-syntax-options">Alternate Syntax Options</a> at the end for an exploration of syntactic options in this space.</p>
<p>It is important to understand up-front, that the proposed coroutine model does not interface<br>with any particular concurrency primitives on the system: you can think of it as syntactic<br>sugar for completion handlers.  This means that the introduction of coroutines would not<br>change the queues that completion handlers are called on, as happens in some other systems.</p>
<h3 id="Async-semantics"><a href="#Async-semantics" class="headerlink" title="Async semantics"></a>Async semantics</h3><p>Today, function types can be normal or <code>throw</code>ing.  This proposal extends them to also be allowed to be <code>async</code>.  These are all valid function types:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Int</span>) -&gt; <span class="type">Int</span>               <span class="comment">// #1: Normal function</span></span><br><span class="line">(<span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Int</span>        <span class="comment">// #2: Throwing function</span></span><br><span class="line">(<span class="type">Int</span>) async -&gt; <span class="type">Int</span>         <span class="comment">// #3: Asynchronous function</span></span><br><span class="line">(<span class="type">Int</span>) async <span class="keyword">throws</span> -&gt; <span class="type">Int</span>  <span class="comment">// #4: Asynchronous function, can also throw.</span></span><br></pre></td></tr></table></figure>
<p>Just as a normal function (#1) will implicitly convert to a throwing function (#2), an async function (#3) implicitly converts to a throwing async function (#4).</p>
<p>On the function declaration side of the things, you can declare a function as being asynchronous just as you declare it to be throwing, but use the <code>async</code> keyword:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async -&gt; <span class="type">Image</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Semantically similar to this:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">(completionHandler: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Calls to <code>async</code> functions can implicitly suspend the current coroutine.  To make this apparent to maintainers of code, you are required to “mark” expressions that call <code>async</code> functions with the new <code>await</code> keyword (exactly analogously to how <code>try</code> is used to mark subexpressions that contain throwing calls).  Putting these pieces together, the first example (from the pyramid of doom explanation, above) can be rewritten in a more natural way:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> async -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> async -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(<span class="number">_</span> i : Image)</span></span> async -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">()</span></span> async -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = await loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = await loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = await decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   =  await dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Under the hood, the compiler rewrites this code using nested closures like in example <code>processImageData1</code> above. Note that every operation starts only after the previous one has completed, but each call site to an <code>async</code> function could suspend execution of the current function.</p>
<p>Finally, you are only allowed to invoke an <code>async</code> function from within another <code>async</code> function or closure.  This follows the model of Swift 2 error handling, where you cannot call a throwing function unless you’re in a throwing function or inside of a <code>do/catch</code> block.</p>
<h4 id="Entering-and-leaving-async-code"><a href="#Entering-and-leaving-async-code" class="headerlink" title="Entering and leaving async code"></a>Entering and leaving async code</h4><p>In the common case, async code ought to be invoking other async code that has been dispatched by the framework the app is built on top of, but at some point, an async process needs to spawn from a controlling synchronous context, and the async process needs to be able to suspend itself and allow its <strong>continuation</strong> to be scheduled by the controlling context. We need a couple of primitives to<br>enable entering and suspending an async context:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NB: Names subject to bikeshedding. These are low-level primitives that most</span></span><br><span class="line"><span class="comment">// users should not need to interact with directly, so namespacing them</span></span><br><span class="line"><span class="comment">// and/or giving them verbose names unlikely to collide or pollute code</span></span><br><span class="line"><span class="comment">// completion (and possibly not even exposing them outside the stdlib to begin</span></span><br><span class="line"><span class="comment">// with) would be a good idea.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Begins an asynchronous coroutine, transferring control to `body` until it</span></span><br><span class="line"><span class="comment">/// either suspends itself for the first time with `suspendAsync` or completes,</span></span><br><span class="line"><span class="comment">/// at which point `beginAsync` returns. If the async process completes by</span></span><br><span class="line"><span class="comment">/// throwing an error before suspending itself, `beginAsync` rethrows the error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beginAsync</span><span class="params">(<span class="number">_</span> body: <span class="params">()</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Suspends the current asynchronous task and invokes `body` with the task's</span></span><br><span class="line"><span class="comment">/// continuation closure. Invoking `continuation` will resume the coroutine</span></span><br><span class="line"><span class="comment">/// by having `suspendAsync` return the value passed into the continuation.</span></span><br><span class="line"><span class="comment">/// It is a fatal error for `continuation` to be invoked more than once.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suspendAsync</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(<span class="number">_</span> continuation: @escaping <span class="params">(T)</span></span></span></span> -&gt; ()) -&gt; ()</span><br><span class="line">) async -&gt; <span class="type">T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Suspends the current asynchronous task and invokes `body` with the task's</span></span><br><span class="line"><span class="comment">/// continuation and failure closures. Invoking `continuation` will resume the</span></span><br><span class="line"><span class="comment">/// coroutine by having `suspendAsync` return the value passed into the</span></span><br><span class="line"><span class="comment">/// continuation. Invoking `error` will resume the coroutine by having</span></span><br><span class="line"><span class="comment">/// `suspendAsync` throw the error passed into it. Only one of</span></span><br><span class="line"><span class="comment">/// `continuation` and `error` may be called; it is a fatal error if both are</span></span><br><span class="line"><span class="comment">/// called, or if either is called more than once.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suspendAsync</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(<span class="number">_</span> continuation: @escaping <span class="params">(T)</span></span></span></span> -&gt; (),</span><br><span class="line">           <span class="number">_</span> error: @escaping (<span class="type">Error</span>) -&gt; ()) -&gt; ()</span><br><span class="line">) async <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>These are similar to the “shift” and “reset” primitives of <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVkX2NvbnRpbnVhdGlvbg==" title="https://en.wikipedia.org/wiki/Delimited_continuation">delimited continuations<i class="fa fa-external-link"></i></span>.  These enable a non-async function to call an <code>async</code> function.  For example, consider this<br><code>@IBAction</code> written with completion handlers:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonDidClick</span><span class="params">(sender:AnyObject)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  processImage(completionHandler: &#123;(image) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    imageView.image = image</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is an essential pattern, but is itself sort of odd: an <code>async</code> operation is being fired off immediately (#1), then runs the subsequent code (#3), and the completion handler (#2) runs at some time later — on some queue (often the main one).  This pattern frequently leads to mutation of global state (as in this example) or to making assumptions about which queue the completion handler is run on.  Despite these problems, it is essential that the model encompasses this pattern, because it is a practical necessity in Cocoa development.  With this proposal, it would look like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonDidClick</span><span class="params">(sender:AnyObject)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  beginAsync &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> image = await processImage()</span><br><span class="line">    imageView.image = image</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These primitives enable callback-based APIs to be wrapped up as async coroutine APIs:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Legacy callback-based API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStuff</span><span class="params">(completion: <span class="params">(Stuff)</span></span></span> -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStuff</span><span class="params">()</span></span> async -&gt; <span class="type">Stuff</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> await suspendAsync &#123; continuation <span class="keyword">in</span></span><br><span class="line">    getStuff(completion: continuation)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Functionality of concurrency libraries such as libdispatch and pthreads can<br>also be presented in coroutine-friendly ways:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Move execution of the current coroutine synchronously onto this queue.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">syncCoroutine</span><span class="params">()</span></span> async -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    await suspendAsync &#123; continuation <span class="keyword">in</span></span><br><span class="line">      sync &#123; continuation &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Enqueue execution of the remainder of the current coroutine</span></span><br><span class="line">  <span class="comment">/// asynchronously onto this queue.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">asyncCoroutine</span><span class="params">()</span></span> async -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    await suspendAsync &#123; continuation <span class="keyword">in</span></span><br><span class="line">      async &#123; continuation &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queueHopping</span><span class="params">()</span></span> async -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  doSomeStuff()</span><br><span class="line">  await <span class="type">DispatchQueue</span>.main.syncCoroutine()</span><br><span class="line">  doSomeStuffOnMainThread()</span><br><span class="line">  await backgroundQueue.asyncCoroutine()</span><br><span class="line">  doSomeStuffInBackground()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generalized abstractions for coordinating coroutines can also be built. The simplest of these is a <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnV0dXJlc19hbmRfcHJvbWlzZXM=" title="https://en.wikipedia.org/wiki/Futures_and_promises">future<i class="fa fa-external-link"></i></span>, a value that represents a future value which may not be resolved yet.  The exact design for a Future type is out of scope for this proposal (it should be its own follow-on proposal), but an example proof of concept could look like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123; <span class="keyword">case</span> error(<span class="type">Error</span>), value(<span class="type">T</span>) &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> result: <span class="type">Result?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> awaiters: [(<span class="type">Result</span>) -&gt; <span class="type">Void</span>] = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fulfill the future, and resume any coroutines waiting for the value.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fulfill</span><span class="params">(<span class="number">_</span> value: T)</span></span> &#123;</span><br><span class="line">    <span class="built_in">precondition</span>(<span class="keyword">self</span>.result == <span class="literal">nil</span>, <span class="string">"can only be fulfilled once"</span>)</span><br><span class="line">    <span class="keyword">let</span> result = .value(value)</span><br><span class="line">    <span class="keyword">self</span>.result = result</span><br><span class="line">    <span class="keyword">for</span> awaiter <span class="keyword">in</span> awaiters &#123;</span><br><span class="line">      <span class="comment">// A robust future implementation should probably resume awaiters</span></span><br><span class="line">      <span class="comment">// concurrently into user-controllable contexts. For simplicity this</span></span><br><span class="line">      <span class="comment">// proof-of-concept simply resumes them all serially in the current</span></span><br><span class="line">      <span class="comment">// context.</span></span><br><span class="line">      awaiter(result)</span><br><span class="line">    &#125;</span><br><span class="line">    awaiters = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the future as having failed to produce a result.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">fail</span><span class="params">(<span class="number">_</span> error: Error)</span></span> &#123;</span><br><span class="line">    <span class="built_in">precondition</span>(<span class="keyword">self</span>.result == <span class="literal">nil</span>, <span class="string">"can only be fulfilled once"</span>)</span><br><span class="line">    <span class="keyword">let</span> result = .error(error)</span><br><span class="line">    <span class="keyword">self</span>.result = result</span><br><span class="line">    <span class="keyword">for</span> awaiter <span class="keyword">in</span> awaiters &#123;</span><br><span class="line">      awaiter(result)</span><br><span class="line">    &#125;</span><br><span class="line">    awaiters = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="comment">// Throw/return the result immediately if available.</span></span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> e)?:</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    <span class="keyword">case</span> .value(<span class="keyword">let</span> v)?:</span><br><span class="line">      <span class="keyword">return</span> v</span><br><span class="line">    <span class="comment">// Wait for the future if no result has been fulfilled.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      <span class="keyword">return</span> await suspendAsync &#123; continuation, error <span class="keyword">in</span></span><br><span class="line">        awaiters.append(&#123;</span><br><span class="line">          <span class="keyword">switch</span> $<span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> .error(<span class="keyword">let</span> e): error(e)</span><br><span class="line">          <span class="keyword">case</span> .value(<span class="keyword">let</span> v): continuation(v)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an unfulfilled future.</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Begin a coroutine by invoking `body`, and create a future representing</span></span><br><span class="line">  <span class="comment">// the eventual result of `body`'s completion.</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="number">_</span> body: () async -&gt; <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">    beginAsync &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.fulfill(await body())</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.fail(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To reiterate, it is well known that this specific implementation has performance and API weaknesses, the point is merely to sketch how an abstraction like this could be built on top of <code>async</code>/<code>await</code>.</p>
<p>Futures allow parallel execution, by moving <code>await</code> from the call to the result when it is needed, and wrapping the parallel calls in individual <code>Future</code> objects:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1a</span><span class="params">()</span></span> async -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = <span class="type">Future</span> &#123; await loadWebResource(<span class="string">"dataprofile.txt"</span>) &#125;</span><br><span class="line">  <span class="keyword">let</span> imageResource = <span class="type">Future</span> &#123; await loadWebResource(<span class="string">"imagedata.dat"</span>) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... other stuff can go here to cover load latency...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> imageTmp    = await decodeImage(dataResource.<span class="keyword">get</span>(), imageResource.<span class="keyword">get</span>())</span><br><span class="line">  <span class="keyword">let</span> imageResult = await dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the above example, the first two operations will start one after another, and the unevaluated computations are wrapped into a <code>Future</code> value.  This allows all of them to happen concurrently (in a way that need not be defined by the language or by the <code>Future</code> implementation), and the function will wait for completion of them before decoding the image.  Note that <code>await</code> does not block flow of execution: if the value is not yet ready, execution of the current <code>async</code> function is suspended, and control flow passes to something higher up in the stack.</p>
<p>Other coordination abstractions such as <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tbXVuaWNhdGluZ19zZXF1ZW50aWFsX3Byb2Nlc3Nlcw==" title="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Process channels<i class="fa fa-external-link"></i></span> or <span class="exturl" data-url="aHR0cHM6Ly93aW5nb2xvZy5vcmcvYXJjaGl2ZXMvMjAxNy8wNi8yOS9hLW5ldy1jb25jdXJyZW50LW1s" title="https://wingolog.org/archives/2017/06/29/a-new-concurrent-ml">Concurrent ML events<i class="fa fa-external-link"></i></span> can also be developed as libraries for coordinating coroutines; their implementation is left as an exercise for the reader.</p>
<h2 id="Conversion-of-imported-Objective-C-APIs"><a href="#Conversion-of-imported-Objective-C-APIs" class="headerlink" title="Conversion of imported Objective-C APIs"></a>Conversion of imported Objective-C APIs</h2><p>Full details are beyond the scope of this proposal, but it is important to enhance the importer to project Objective-C completion-handler based APIs into <code>async</code> forms.  This is a transformation comparable to how <code>NSError**</code> functions are imported as <code>throws</code> functions.  Having the importer do this means that many Cocoa APIs will be modernized en masse.</p>
<p>There are multiple possible designs for this with different tradeoffs.  The maximally source compatible way to do this is to import completion handler-based APIs in two forms: both the completion handler and the <code>async</code> form.  For example, given:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">- (<span class="keyword">void</span>) processImageData:(<span class="keyword">void</span>(^)())completionHandler;</span><br><span class="line">- (<span class="keyword">void</span>) processImageData:(<span class="keyword">void</span>(^)(Image* __<span class="keyword">nonnull</span> image))completionHandler;</span><br><span class="line">- (<span class="keyword">void</span>) processImageData:(<span class="keyword">void</span>(^)(Image* __<span class="keyword">nullable</span> image1, <span class="built_in">NSError</span>* __<span class="keyword">nullable</span> error))completionHandler;</span><br><span class="line">- (<span class="keyword">void</span>) processImageData:(<span class="keyword">void</span>(^)(Image* __<span class="keyword">nullable</span> half1, Image* __<span class="keyword">nullable</span> half2, <span class="built_in">NSError</span>* __<span class="keyword">nullable</span> error))completionHandler;</span><br><span class="line">- (<span class="keyword">void</span>) processImageData:(<span class="keyword">void</span>(^)(<span class="built_in">NSError</span>* __<span class="keyword">nullable</span> error))completionHandler;</span><br></pre></td></tr></table></figure>
<p>The declarations above are imported both in their normal completion handler form, but also in their nicer <code>async</code> forms:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; (half1: <span class="type">Image</span>, half2: <span class="type">Image</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<p>There are many details that should be defined as part of this importing process - for example:</p>
<ul>
<li>What are the exact rules for the transformation?</li>
<li>Are multiple result functions common enough to handle automatically?</li>
<li>Would it be better to just import completion handler functions only as <code>async</code> in Swift 5 mode, forcing migration?</li>
<li>What should happen with the non-Void-returning completion handler functions (e.g. in <code>URLSession</code>)?</li>
<li>Should <code>Void</code>-returning methods that are commonly used to trigger asynchronous operations in response to events, such as <code>IBAction</code> methods, be imported as <code>async -&gt; Void</code>?</li>
</ul>
<p>Without substantial ObjC importer work, making a clean break and forcing migration in Swift 5 mode would be the most practical way to preserve overridability, but would create a lot of churn in 4-to-5 migration. Alternatively, it may be acceptable to present the <code>async</code> versions as <code>final</code> wrappers over the underlying callback-based interfaces; this would subclassers to work with the callback-based interface, but there are generally fewer subclassers than callers.</p>
<h2 id="Interaction-with-existing-features"><a href="#Interaction-with-existing-features" class="headerlink" title="Interaction with existing features"></a>Interaction with existing features</h2><p>This proposal dovetails naturally with existing language features in Swift, here are a few examples:</p>
<h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><p>Error handling syntax introduced in Swift 2 composes naturally with this asynchronous model.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Could throw or be interrupted:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Semantically similar to:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">(completionHandler: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>
<p>Our example thus becomes (compare with the example <code>processImageData2</code>):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(i: Image)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Vegetable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = <span class="keyword">try</span> await loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = <span class="keyword">try</span> await loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = <span class="keyword">try</span> await decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   = <span class="keyword">try</span> await dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coroutines address one of the major shortcomings of the Swift 2 error model,<br>that it did not interoperate well with callback-oriented asynchronous APIs and<br>required clumsy boilerplate to propagate errors across callback boundaries.</p>
<h4 id="Closure-type-inference"><a href="#Closure-type-inference" class="headerlink" title="Closure type inference"></a>Closure type inference</h4><p>Because the <code>await</code> keyword is used at all points where execution may be suspended, it is simple for the compiler to determine whether a closure is <code>async</code> or not: it is if the body includes an <code>await</code>.  This works exactly the same way that the presence of <code>try</code> in a closure causes it to be inferred as a throwing closure.  You can also explicitly mark a closure as <code>async</code> using the standard form of:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myClosure = &#123; () async -&gt; () <span class="keyword">in</span> ... &#125;</span><br></pre></td></tr></table></figure>
<h4 id="defer-and-abandonment"><a href="#defer-and-abandonment" class="headerlink" title="defer and abandonment"></a><code>defer</code> and abandonment</h4><p>Coroutines can be suspended, and while suspended, there is the potential for a coroutine’s execution to be <strong>abandoned</strong> if all references to its continuation<br>closure(s) are released without being executed:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Shut down the current coroutine and give its memory back to the</span></span><br><span class="line"><span class="comment">/// shareholders.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abandon</span><span class="params">()</span></span> async -&gt; <span class="type">Never</span> &#123;</span><br><span class="line">  await suspendAsync &#123; <span class="number">_</span> = $<span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is to be expected that, upon abandonment, any references captured in wait by the continuation should be released, as with any closure. However, there may be other cleanup that must be guaranteed to occur. <code>defer</code> serves the general<br>role of “guaranteed cleanup” in synchronous code, and it would be a natural<br>extension to add the guarantee that <code>defer</code>-ed statements also execute as part<br>of cleaning up an abandoned coroutine:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  startProgressBar()</span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    <span class="comment">// This will be called when error is thrown, when all operations</span></span><br><span class="line">    <span class="comment">// complete and a result is returned, or when the coroutine is</span></span><br><span class="line">    <span class="comment">// abandoned. We don't want to leave the progress bar animating if</span></span><br><span class="line">    <span class="comment">// work has stopped.</span></span><br><span class="line">    stopProgressBar()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataResource  = <span class="keyword">try</span> await loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = <span class="keyword">try</span> await loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imageTmp    = <span class="keyword">try</span> await decodeImage(dataResource, imageResource)</span><br><span class="line">  &#125; <span class="keyword">catch</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">CorruptedImage</span> &#123;</span><br><span class="line">    <span class="comment">// Give up hope now.</span></span><br><span class="line">    await abandon()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> await dewarpAndCleanupImage(imageTmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This fills in another gap in the expressivity of callback-based APIs, where it is difficult to express cleanup code that must execute at some point regardless of whether the callback closure is really called. However, abandonment should not be taken as a fully-baked “cancellation” feature; if cancellation is important, it should continue to be implemented by the programmer where needed, and there are many standard patterns that can be applied. Particularly when coupled with error handling, common cancellation patterns become very elegant:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func processImageData(sender: AnyObject) &#123;</span><br><span class="line">  beginAsync &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">      let dataResource  &#x3D; try await imageProcessor.loadWebResource(&quot;dataprofile.txt&quot;)</span><br><span class="line">      let imageResource &#x3D; try await imageProcessor.loadWebResource(&quot;imagedata.dat&quot;)</span><br><span class="line">      let imageTmp      &#x3D; try await imageProcessor.decodeImage(dataResource, imageResource)</span><br><span class="line">      let imageResult   &#x3D; try await imageProcessor.dewarpAndCleanupImage(imageTmp)</span><br><span class="line">      display(imageResult)</span><br><span class="line">    &#125; catch CocoaError.userCancelled &#123;</span><br><span class="line">      &#x2F;&#x2F; Ignore, user quit the kitchen.</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      &#x2F;&#x2F; Some really interesting error happened</span><br><span class="line">      presentError(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@IBAction func stopImageProcessing(sender: AnyObject) &#123;</span><br><span class="line">  imageProcessor.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Internally, <code>imageProcessor</code> may use <code>NSOperation</code> or a custom <code>cancelled</code> flag. The intent of this section is to give a single example of how to approach this, not to define a normative or all-encompassing approach that should be used in all cases.</p>
<h4 id="Completion-handlers-with-multiple-return-values"><a href="#Completion-handlers-with-multiple-return-values" class="headerlink" title="Completion handlers with multiple return values"></a>Completion handlers with multiple return values</h4><p>Completion handler APIs may have multiple result arguments (not counting an error argument). These are naturally represented by tuple results in <code>async</code> functions:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageHalves</span><span class="params">(completionHandler: <span class="params">(part1: Image?, part2: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageHalves</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; (<span class="type">Image</span>, <span class="type">Image</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Source-Compatibility"><a href="#Source-Compatibility" class="headerlink" title="Source Compatibility"></a>Source Compatibility</h2><p>This is a generally additive feature, but it does take <code>async</code> and <code>await</code> as keywords, so it will break code that uses them as identifiers.  This is expected to have very minor impact: the most pervasive use of <code>async</code> as an identifier occurs in code that works with dispatch queues, but fortunately keywords are allowed as qualified member names, so code like this doesn’t need any change:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myQueue.async &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>That said, there could be obscure cases that break.  One example that occurs in the Swift testsuite is of the form:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">myThing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This can be addressed by changing the code to use <code>self.async</code> or backticks.  The compiler should be able to detect a large number of these cases and produce a fixit.</p>
<h2 id="Effect-on-ABI-stability"><a href="#Effect-on-ABI-stability" class="headerlink" title="Effect on ABI stability"></a>Effect on ABI stability</h2><p>This proposal does not change the ABI of any existing language features, but does introduce a new concept that adds to the ABI surface area, including a new mangling and calling convention.</p>
<h2 id="Alternate-Syntax-Options"><a href="#Alternate-Syntax-Options" class="headerlink" title="Alternate Syntax Options"></a>Alternate Syntax Options</h2><p>Here are a couple of syntax level changes to the proposal that are worth discussing, these don’t fundamentally change the shape of the proposal.</p>
<h4 id="Spelling-of-async-keyword"><a href="#Spelling-of-async-keyword" class="headerlink" title="Spelling of async keyword"></a>Spelling of <code>async</code> keyword</h4><p>Instead of spelling the function type modifier as <code>async</code>, it could be spelled as <code>yields</code>, since the functionality really is about coroutines, not about asynchrony by itself.  The recommendation to use <code>async/await</code> biases towards making sure that the most common use case (asynchrony) uses industry standard terms.  The other coroutine use cases would be much less common, at least according to the unscientific opinion of the proposal authors.</p>
<p>To give an idea of what this could look like, here’s the example from above resyntaxed:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> yields -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> yields -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(<span class="number">_</span> i : Image)</span></span> yields -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">()</span></span> yields -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = yield loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = yield loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = yield decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   = yield dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Make-async-be-a-subtype-of-throws-instead-of-orthogonal-to-it"><a href="#Make-async-be-a-subtype-of-throws-instead-of-orthogonal-to-it" class="headerlink" title="Make async be a subtype of throws instead of orthogonal to it"></a>Make <code>async</code> be a subtype of <code>throws</code> instead of orthogonal to it</h4><p>It would be a great simplification of the language model to make the <code>async</code> modifier on a function imply that the function is <code>throw</code>ing, instead of making them orthogonal modifiers.  From an intuitive perspective, this makes sense because many of the sorts of operations that are asynchronous (e.g. loading a resource, talking to the network, etc) can also fail.   There is also precedent from many other systems that use <code>async</code>/<code>await</code> for this; for example, .NET <code>Task</code>s and Javascript promises both combine error handling with async sequencing. One could argue that that’s because .NET and Javascript’s established runtimes both feature pervasive implicit exceptions; however, popular async frameworks for the Rust programming language, such as <span class="exturl" data-url="aHR0cHM6Ly90b2tpby5ycw==" title="https://tokio.rs">tokio.rs<i class="fa fa-external-link"></i></span>, have also chosen to incorporate error handling directly into their <code>Future</code> constructs, because doing so was found to be more practical and ergonomic than trying to compose theoretically-orthogonal <code>Future&lt;T&gt;</code> and <code>Result&lt;T&gt;</code> constructs.</p>
<p>If we made <code>async</code> a subtype of <code>throws</code>, then instead of four kinds of function type, we’d only have three:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Int</span>) -&gt; <span class="type">Int</span>               <span class="comment">// Normal function</span></span><br><span class="line">(<span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Int</span>        <span class="comment">// Throwing function</span></span><br><span class="line">(<span class="type">Int</span>) async -&gt; <span class="type">Int</span>         <span class="comment">// Asynchronous function, can also throw</span></span><br></pre></td></tr></table></figure>
<p>The <code>try</code> marker could also be dropped from <code>try await</code>, because all <code>await</code>s would be known to throw.  For user code, you would never need the ugly <code>async throws</code> modifier stack.</p>
<p>A downside to doing this is that Cocoa in practice does have a number of completion handler APIs that do not take error arguments, and not having the ability to express that would make the importer potentially lose type information. Many of these APIs express failure in more limited ways, such as passing <code>nil</code> into the completion closure, passing in a <code>BOOL</code> to indicate success, or communicating status via side properties of the coordinating object; auditing for and recognizing all of these idioms would complicate the importer and slow the SDK modernization process. Even then, Swift subclassers overriding the <code>async</code> forms of these APIs would be allowed by the language to throw errors even though the error cannot really be communicated across the underlying Objective-C interface.</p>
<h4 id="Make-async-default-to-throws"><a href="#Make-async-default-to-throws" class="headerlink" title="Make async default to throws"></a>Make <code>async</code> default to <code>throws</code></h4><p>The other way to factor the complexity is to make it so that <code>async</code> functions default to <code>throw</code>ing, but still allow non-<code>throw</code>ing <code>async</code> functions to be expressed with <code>nonthrowing</code> (or some other spelling).  This provides this model:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Int</span>) -&gt; <span class="type">Int</span>                     <span class="comment">// Normal function</span></span><br><span class="line">(<span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Int</span>              <span class="comment">// Throwing function</span></span><br><span class="line">(<span class="type">Int</span>) async -&gt; <span class="type">Int</span>               <span class="comment">// Asynchronous function, can also throw.</span></span><br><span class="line">(<span class="type">Int</span>) async(nonthrowing) -&gt; <span class="type">Int</span>  <span class="comment">// Asynchronous function, doesn't throw.</span></span><br></pre></td></tr></table></figure>
<p>This model provides a ton of advantages: it is arguably the right defaults for the vast majority of clients (reducing boilerplate and syntactic noise), provides the ability for the importer and experts to get what they want.  The only downside of is that it is a less obvious design than presenting two orthogonal axes, but in the opinion of the proposal authors, this is probably the right set of tradeoffs.</p>
<h4 id="Behavior-of-beginAsync-and-suspendAsync-operations"><a href="#Behavior-of-beginAsync-and-suspendAsync-operations" class="headerlink" title="Behavior of beginAsync and suspendAsync operations"></a>Behavior of <code>beginAsync</code> and <code>suspendAsync</code> operations</h4><p>For async code to be able to interact with synchronous code, we need at least two primitive operations: one to enter a suspendable context, and another to suspend the current context and yield control back to the outer context. Aside from the obvious naming bikeshed, there are some other design details to consider. As proposed, <code>beginAsync</code> and continuation closures return <code>Void</code> to the calling context, but it may be desirable instead to have them return a value indicating whether the return was because of suspension or completion of the async task, e.g.:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Begin execution of `body`. Return `true` if it completes, or `false` if it</span></span><br><span class="line"><span class="comment">/// suspends.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beginAsync</span><span class="params">(<span class="number">_</span> body: <span class="params">()</span></span></span> async -&gt; ()) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="comment">/// Suspend execution of the current coroutine, passing the current continuation/// into `body` and then returning `false` to the controlling context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suspendAsync</span>&lt;T&gt;<span class="params">(<span class="number">_</span> body: <span class="params">(<span class="number">_</span> resume: <span class="params">(T)</span></span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Void</span>) async -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>Instead of representing the continuation as a plain function value passed into the <code>suspendAsync</code> primitive, a specialized <code>Continuation&lt;T&gt;</code> type could be devised. Continuations are one-shot, and a nominal continuation type could statically enforce this by being a move-only type consumed by the resume operation. The continuation could also be returned by <code>beginAsync</code> or resuming a continuation instead of being passed into <code>suspendAsync</code>, which would put the responsibility for scheduling the continuation into the code that starts the coroutine instead of in the code that causes the suspension. There are tradeoffs to either approach.</p>
<h2 id="Alternatives-Considered"><a href="#Alternatives-Considered" class="headerlink" title="Alternatives Considered"></a>Alternatives Considered</h2><h4 id="Include-Future-or-other-coordination-abstractions-in-this-proposal"><a href="#Include-Future-or-other-coordination-abstractions-in-this-proposal" class="headerlink" title="Include Future or other coordination abstractions in this proposal"></a>Include <code>Future</code> or other coordination abstractions in this proposal</h4><p>This proposal does not formally propose a <code>Future</code> type, or any other coordination abstractions. There are many rational designs for futures, and a lot of experience working with them. On the other hand, there are also completely different coordination primitives that can be used with this coroutine design, and incorporating them into this proposal only makes it larger.</p>
<p>Furthermore, the shape and functionality of a future may also be affected by Swift’s planned evolution. A <code>Future</code> type designed for Swift today would need to be a <code>class</code>, and therefore need to guard against potentially multithreaded access, races to fulfill or attempts to fulfill multiple times, and potentially unbounded queueing of awaiting coroutines on the shared future; however, the introduction of ownership and move-only types would allow us to express futures as a more efficient move-only type requiring exclusive ownership to be forwarded from the fulfilling task to the receiving task, avoiding the threading and queueing problems of a class-based approach, as seen in Rust’s <span class="exturl" data-url="aHR0cHM6Ly90b2tpby5ycw==" title="https://tokio.rs">tokio.rs<i class="fa fa-external-link"></i></span> framework. tokio.rs and the C++ coroutine TR also both take the approach of making futures/continuations into templated/generic traits instead of a single concrete implementation, so that the compiler can deeply specialize and optimize state machines for composed async operations. tokio.rs and the C++ coroutine TR also both take the approach of making futures/continuations into templated/generic traits instead of a single concrete implementation, so that the compiler can deeply specialize and optimize state machines for composed async operations. Whether that is a good design for Swift as well needs further exploration.</p>
<h4 id="Have-async-calls-always-return-a-Future"><a href="#Have-async-calls-always-return-a-Future" class="headerlink" title="Have async calls always return a Future"></a>Have async calls always return a <code>Future</code></h4><p>The most commonly cited alternative design is to follow the model of (e.g.) C#, where calls to async functions return a future (aka <code>Task</code> in C#), instead of futures being a library feature separable from the core language.  Going this direction adds async/await to the language instead of adding a more general coroutine feature.</p>
<p>Despite this model being widely know, we believe that the proposed design is<br> superior for a number of reasons:</p>
<ul>
<li>Coroutines are generally useful language features beyond the domain of async/await.  For example, building async/await into the compiler would require building generators in as well.</li>
<li>The proposed design eliminates the problem of calling an API (without knowing it is async) and getting a <code>Future&lt;T&gt;</code> back instead of the expected <code>T</code> result type.  C# addresses this by suggesting that all <code>async</code> methods have their name be suffixed with <code>Async</code>, which is suboptimal.</li>
<li>By encoding <code>async</code> as a first-class part of function types, closure literals can also be transparently <code>async</code> by contextual type inference. In the future, mechanisms like <code>rethrows</code> can be extended to allow polymorphism over asynchrony for higher-level operations like <code>map</code> to work as expected without creating intermediate collections of <code>Future&lt;T&gt;</code>, although this proposal does not propose any such abstraction mechanisms in the short term.</li>
<li>The C# model for await is a unary prefix keyword, which does not compose well in the face of chaining.  Wherein C# you may have to write something like <code>x = await (await foo()).bar()</code>, with the proposed design you can simply write <code>x = await foo().bar()</code> for the same reasons that you don’t have to write <code>try</code> on every single call in a chain that can throw.</li>
<li>It is useful to be able to design and discuss futures as an independent standard library feature without tying the entire success or failure of coroutines as a language proposal to <code>Future</code>‘s existence.</li>
<li>There are multiple different interesting abstractions besides futures to consider.  By putting the details of them in the standard library, other people can define and use their own abstractions where it makes sense.</li>
<li>Requiring a future object to be instantiated at every <code>await</code> point adds overhead. Since a major use case for this feature is to adapt existing Cocoa APIs, which already use callbacks, queues, target-action, or other mechanisms to coordinate the scheduling of the continuation of an async task, introducing a future into the mix would be an additional unnecessary middleman incurring overhead when wrapping these APIs, when in most cases there is already a direct consumer for the continuation point.</li>
<li>A design that directly surfaces a monadic type like <code>Future</code> as the result of an async computation heavily implies a compiler-driven coroutine transform, whereas this design is more implementation-agnostic. Compiler-transformed coroutines are a great compromise for integrating lightweight tasks into an existing runtime model that’s already heavily callstack-dependent, or one aims to maintain efficient interop with C or other languages that heavily constrain the implementation model, and Swift definitely has both. It is conceivable that, in the eventual future, a platform such as Swift-on-the-server could provide a pure- or predominantly-Swift ABI where enough code is pure Swift to make cheap relocatable stacks the norm and overhead on C interop acceptable, as has happened with the Go runtime. This could make <code>async</code> a no-op at runtime, and perhaps allow us to consider eliminating the annotation altogether. The semantic presence of a future object between every layer of an async process would be an obstacle to the long-term efficiency of such a platform.</li>
</ul>
<p>The primary argument for adding async/await (and then generators) to the language as first-class language features is that they are the vastly most common use-case of coroutines.  In the author’s opinion, the design as proposed gives something that works better than the C# model in practice, while also providing a more useful/general language model.</p>
<h4 id="Have-a-generalized-“do-notation”-for-monadic-types"><a href="#Have-a-generalized-“do-notation”-for-monadic-types" class="headerlink" title="Have a generalized “do notation” for monadic types"></a>Have a generalized “do notation” for monadic types</h4><p>Another approach to avoiding the one-true-future-type problem of C# could be to have a general language feature for chaining continuations through a monadic interface. Although this provides a more general language feature, it still has many of the shortcomings discussed above; it would still perform only a shallow transform of the current function body and introduce a temporary value at every point the coroutine is “awaited”. Monads also compose poorly with each other, and require additional lifting and transformation logic to plumb through higher-order operations, which were some of the reasons we also chose not to base Swift’s error handling model on sugar over <code>Result</code> types. Note that the delimited continuation primitives offered in this proposal are general purpose and can in fact be used to represent monadic unwrapping operations for types like <code>Optional</code> or <code>Result</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOptional</span>&lt;T&gt;<span class="params">(<span class="number">_</span> body: <span class="params">(<span class="number">_</span> unwrap: <span class="params">(T?)</span></span></span></span> async -&gt; <span class="type">T</span>) async -&gt; <span class="type">T?</span>) -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result: <span class="type">T?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">unwrap</span><span class="params">(<span class="number">_</span> value: T?)</span></span> async -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = value &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    suspendAsync &#123; <span class="number">_</span> <span class="keyword">in</span> result = <span class="literal">nil</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beginAsync &#123;</span><br><span class="line">    body(unwrap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monads that represent repeated or nondeterministic operations would not be representable this way due to the one-shot constraint on continuations, but representing such computations as straight-line code in an imperative language with shared mutable state seems like a recipe for disaster to us.</p>
<h2 id="Potential-Future-Directions"><a href="#Potential-Future-Directions" class="headerlink" title="Potential Future Directions"></a>Potential Future Directions</h2><p>This proposal has been kept intentionally minimal, but there are many possible ways to expand this in the future.  For example:</p>
<h4 id="New-Foundation-GCD-and-Server-APIs"><a href="#New-Foundation-GCD-and-Server-APIs" class="headerlink" title="New Foundation, GCD, and Server APIs"></a>New Foundation, GCD, and Server APIs</h4><p>Given the availability of convenient asynchrony in Swift, it would make sense to introduce new APIs to take advantage of it.  Filesystem APIs are one example that would be great to see.  The Swift on Server working group would also widely adopt these features. GCD could also provide new helpers for allowing <code>() async -&gt; Void</code> coroutines to be enqueued, or for allowing a running coroutine to move its execution onto a different queue.</p>
<h4 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h4><p>As part of this introduction it makes sense to extend the Swift API design guidelines and other documentation to describe and encourage best practices in asynchronous API design.</p>
<h4 id="rethrows-could-be-generalized-to-support-potentially-async-operations"><a href="#rethrows-could-be-generalized-to-support-potentially-async-operations" class="headerlink" title="rethrows could be generalized to support potentially async operations"></a><code>rethrows</code> could be generalized to support potentially <code>async</code> operations</h4><p>The <code>rethrows</code> modifier exists in Swift to allow limited abstraction over function types by higher order functions.  It would be possible to define a similar mechanism to allow abstraction over <code>async</code> operations as well. More generally, by modeling both <code>throws</code> and <code>async</code> as effects on function types, we can eventually provide common abstraction tools to abstract over both effects in protocols and generic code, simultaneously addressing the “can’t have a Sequence that <code>throws</code>“ and “can’t have a Sequence that’s <code>async</code>“ kinds of limitations in the language today.</p>
<h4 id="Blocking-calls"><a href="#Blocking-calls" class="headerlink" title="Blocking calls"></a>Blocking calls</h4><p>Affordances could be added to better call blocking APIs from <code>async</code> functions and to hard wait for an <code>async</code> function to complete.  There are significant tradeoffs and wide open design space to explore here, and none of it is necessary for the base proposal.</p>
<h4 id="Fix-queue-hopping-Objective-C-completion-handlers"><a href="#Fix-queue-hopping-Objective-C-completion-handlers" class="headerlink" title="Fix queue-hopping Objective-C completion handlers"></a>Fix queue-hopping Objective-C completion handlers</h4><p>One unfortunate reality of the existing Cocoa stack is that many asynchronous methods are<br>unclear about which queue they run the completion handler on.  In fact, one of the top hits<br>for implementing completion handlers on Stack Overflow includes this Objective-C code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)asynchronousTaskWithCompletion:(void (^)(void))completion;</span><br><span class="line">&#123;</span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Some long running task you want on another thread</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      if (completion) &#123;</span><br><span class="line">        completion();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that it runs the completion handler on the main queue, not on the queue which it was<br>invoked on.  This disparity causes numerous problems for Cocoa programmers, who would<br>probably defensively write the <code>@IBAction</code> above like this (or else face a possible race<br>condition):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonDidClick</span><span class="params">(sender:AnyObject)</span></span> &#123;</span><br><span class="line">  beginAsync &#123;</span><br><span class="line">    <span class="keyword">let</span> image = await processImageData()</span><br><span class="line">    <span class="comment">// Do the update on the main thread/queue since it owns imageView.</span></span><br><span class="line">    mainQ.async &#123;</span><br><span class="line">      imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This can be fixed in the Objective-C importer, which is going to be making thunks for the<br>completion-handler functions anyway: the thunk could check to see if the completion handler<br>is being run on a different queue than the function was invoked on, and if so, enqueue the<br>completion handler on the original queue.</p>
<h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><p>Thanks to @oleganza for the original draft which influenced this!</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/swift/" rel="tag"># swift</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/22/03/2020/An-innovative-approach-to-re-design-mobile-learning-experience-with-X5Learn/" rel="prev" title="An Innovative Approach to Re-Design Mobile Learning Experience with X5Learn">
      <i class="fa fa-chevron-left"></i> An Innovative Approach to Re-Design Mobile Learning Experience with X5Learn
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          table of contents
        </li>
        <li class="sidebar-nav-overview">
          overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Motivation-Completion-handlers-are-suboptimal"><span class="nav-number">2.</span> <span class="nav-text">Motivation: Completion handlers are suboptimal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-1-Pyramid-of-doom"><span class="nav-number">2.0.1.</span> <span class="nav-text">Problem 1: Pyramid of doom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-2-Error-handling"><span class="nav-number">2.0.2.</span> <span class="nav-text">Problem 2: Error handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-3-Conditional-execution-is-hard-and-error-prone"><span class="nav-number">2.0.3.</span> <span class="nav-text">Problem 3: Conditional execution is hard and error-prone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-4-Many-mistakes-are-easy-to-make"><span class="nav-number">2.0.4.</span> <span class="nav-text">Problem 4: Many mistakes are easy to make</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-5-Because-completion-handlers-are-awkward-too-many-APIs-are-defined-synchronously"><span class="nav-number">2.0.5.</span> <span class="nav-text">Problem 5: Because completion handlers are awkward, too many APIs are defined synchronously</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Problem-6-Other-“resumable”-computations-are-awkward-to-define"><span class="nav-number">2.0.6.</span> <span class="nav-text">Problem 6: Other “resumable” computations are awkward to define</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proposed-Solution-Coroutines"><span class="nav-number">3.</span> <span class="nav-text">Proposed Solution: Coroutines</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Async-semantics"><span class="nav-number">3.1.</span> <span class="nav-text">Async semantics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Entering-and-leaving-async-code"><span class="nav-number">3.1.1.</span> <span class="nav-text">Entering and leaving async code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conversion-of-imported-Objective-C-APIs"><span class="nav-number">4.</span> <span class="nav-text">Conversion of imported Objective-C APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interaction-with-existing-features"><span class="nav-number">5.</span> <span class="nav-text">Interaction with existing features</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Error-handling"><span class="nav-number">5.0.1.</span> <span class="nav-text">Error handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Closure-type-inference"><span class="nav-number">5.0.2.</span> <span class="nav-text">Closure type inference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer-and-abandonment"><span class="nav-number">5.0.3.</span> <span class="nav-text">defer and abandonment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Completion-handlers-with-multiple-return-values"><span class="nav-number">5.0.4.</span> <span class="nav-text">Completion handlers with multiple return values</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Source-Compatibility"><span class="nav-number">6.</span> <span class="nav-text">Source Compatibility</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Effect-on-ABI-stability"><span class="nav-number">7.</span> <span class="nav-text">Effect on ABI stability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alternate-Syntax-Options"><span class="nav-number">8.</span> <span class="nav-text">Alternate Syntax Options</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spelling-of-async-keyword"><span class="nav-number">8.0.1.</span> <span class="nav-text">Spelling of async keyword</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Make-async-be-a-subtype-of-throws-instead-of-orthogonal-to-it"><span class="nav-number">8.0.2.</span> <span class="nav-text">Make async be a subtype of throws instead of orthogonal to it</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Make-async-default-to-throws"><span class="nav-number">8.0.3.</span> <span class="nav-text">Make async default to throws</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Behavior-of-beginAsync-and-suspendAsync-operations"><span class="nav-number">8.0.4.</span> <span class="nav-text">Behavior of beginAsync and suspendAsync operations</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alternatives-Considered"><span class="nav-number">9.</span> <span class="nav-text">Alternatives Considered</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Include-Future-or-other-coordination-abstractions-in-this-proposal"><span class="nav-number">9.0.1.</span> <span class="nav-text">Include Future or other coordination abstractions in this proposal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Have-async-calls-always-return-a-Future"><span class="nav-number">9.0.2.</span> <span class="nav-text">Have async calls always return a Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Have-a-generalized-“do-notation”-for-monadic-types"><span class="nav-number">9.0.3.</span> <span class="nav-text">Have a generalized “do notation” for monadic types</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Potential-Future-Directions"><span class="nav-number">10.</span> <span class="nav-text">Potential Future Directions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#New-Foundation-GCD-and-Server-APIs"><span class="nav-number">10.0.1.</span> <span class="nav-text">New Foundation, GCD, and Server APIs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Documentation"><span class="nav-number">10.0.2.</span> <span class="nav-text">Documentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rethrows-could-be-generalized-to-support-potentially-async-operations"><span class="nav-number">10.0.3.</span> <span class="nav-text">rethrows could be generalized to support potentially async operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Blocking-calls"><span class="nav-number">10.0.4.</span> <span class="nav-text">Blocking calls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fix-queue-hopping-Objective-C-completion-handlers"><span class="nav-number">10.0.5.</span> <span class="nav-text">Fix queue-hopping Objective-C completion handlers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thanks"><span class="nav-number">11.</span> <span class="nav-text">Thanks</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">patrick wu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hZ2V0cm9u" title="github → https:&#x2F;&#x2F;github.com&#x2F;magetron"><i class="fa fa-fw fa-github"></i>github</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnBhdHJpY2sud3VAbGludXguY29t" title="email → mailto:patrick.wu@linux.com"><i class="fa fa-fw fa-envelope"></i>email</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9vbGQtYmxvZy5wYXRyaWNrd3UudWs=" title="old-blog → https:&#x2F;&#x2F;old-blog.patrickwu.uk"><i class="fa fa-fw fa-cube"></i>old-blog</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-globe"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">patrick wu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

  

    </div>
</body>
</html>
